///////////////////CODE GENERATED VIA MATHEMATICA///////////////////


#include "../../model.hpp"
#include "utils.hpp"

double DT::H3A0H1Zfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MH1,MZ)*H3A0H1Z(cos_t, s);
}
double DT::H3A0H2Zfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MH2,MZ)*H3A0H2Z(cos_t, s);
}
double DT::H3A0wWfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MW,MW)*H3A0wW(cos_t, s);
}
double DT::H3A0VEvefl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,Mnue,Mnue)*H3A0VEve(cos_t, s);
}
double DT::H3A0VMvmfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,Mnum,Mnum)*H3A0VMvm(cos_t, s);
}
double DT::H3A0VTvtfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,Mnut,Mnut)*H3A0VTvt(cos_t, s);
}
double DT::H3A0Eefl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,Me,Me)*H3A0Ee(cos_t, s);
}
double DT::H3A0Mmfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MM,MM)*H3A0Mm(cos_t, s);
}
double DT::H3A0TAtafl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MTA,MTA)*H3A0TAta(cos_t, s);
}
double DT::H3A0Uufl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MU,MU)*H3A0Uu(cos_t, s);
}
double DT::H3A0Ccfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MC,MC)*H3A0Cc(cos_t, s);
}
double DT::H3A0Ttfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MT,MT)*H3A0Tt(cos_t, s);
}
double DT::H3A0Ddfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MD,MD)*H3A0Dd(cos_t, s);
}
double DT::H3A0Ssfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MS,MS)*H3A0Ss(cos_t, s);
}
double DT::H3A0Bbfl(const double &cos_t, const double &s){
	using namespace PAR;
	return 2*flux(s, MH3,MA0,MB,MB)*H3A0Bb(cos_t, s);
}
