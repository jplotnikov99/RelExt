///////////////////CODE GENERATED VIA MATHEMATICA///////////////////


#include "../../model.hpp"
#include "utils.hpp"

double DT::H3A0H1Zfl(const double &cos_t, const double &s){
	 if(heavi(s,MH1,MZ)){
		 return 2*flux(s, MH3,MA0,MH1,MZ)*H3A0H1Z(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0H2Zfl(const double &cos_t, const double &s){
	 if(heavi(s,MH2,MZ)){
		 return 2*flux(s, MH3,MA0,MH2,MZ)*H3A0H2Z(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0wWfl(const double &cos_t, const double &s){
	 if(heavi(s,MW,MW)){
		 return 2*flux(s, MH3,MA0,MW,MW)*H3A0wW(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0VEvefl(const double &cos_t, const double &s){
	 if(heavi(s,Mnue,Mnue)){
		 return 2*flux(s, MH3,MA0,Mnue,Mnue)*H3A0VEve(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0VMvmfl(const double &cos_t, const double &s){
	 if(heavi(s,Mnum,Mnum)){
		 return 2*flux(s, MH3,MA0,Mnum,Mnum)*H3A0VMvm(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0VTvtfl(const double &cos_t, const double &s){
	 if(heavi(s,Mnut,Mnut)){
		 return 2*flux(s, MH3,MA0,Mnut,Mnut)*H3A0VTvt(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Eefl(const double &cos_t, const double &s){
	 if(heavi(s,Me,Me)){
		 return 2*flux(s, MH3,MA0,Me,Me)*H3A0Ee(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Mmfl(const double &cos_t, const double &s){
	 if(heavi(s,MM,MM)){
		 return 2*flux(s, MH3,MA0,MM,MM)*H3A0Mm(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0TAtafl(const double &cos_t, const double &s){
	 if(heavi(s,MTA,MTA)){
		 return 2*flux(s, MH3,MA0,MTA,MTA)*H3A0TAta(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Uufl(const double &cos_t, const double &s){
	 if(heavi(s,MU,MU)){
		 return 2*flux(s, MH3,MA0,MU,MU)*H3A0Uu(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Ccfl(const double &cos_t, const double &s){
	 if(heavi(s,MC,MC)){
		 return 2*flux(s, MH3,MA0,MC,MC)*H3A0Cc(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Ttfl(const double &cos_t, const double &s){
	 if(heavi(s,MT,MT)){
		 return 2*flux(s, MH3,MA0,MT,MT)*H3A0Tt(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Ddfl(const double &cos_t, const double &s){
	 if(heavi(s,MD,MD)){
		 return 2*flux(s, MH3,MA0,MD,MD)*H3A0Dd(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Ssfl(const double &cos_t, const double &s){
	 if(heavi(s,MS,MS)){
		 return 2*flux(s, MH3,MA0,MS,MS)*H3A0Ss(cos_t, s);
	 }
	 else{ return 0; }

}
double DT::H3A0Bbfl(const double &cos_t, const double &s){
	 if(heavi(s,MB,MB)){
		 return 2*flux(s, MH3,MA0,MB,MB)*H3A0Bb(cos_t, s);
	 }
	 else{ return 0; }

}
